package com.sweetapps.alcoholictimer.core.ads

import android.content.Context
import android.net.ConnectivityManager
import android.util.Log
import com.sweetapps.alcoholictimer.BuildConfig
import com.google.android.gms.ads.AdLoader
import com.google.android.gms.ads.AdRequest
import com.google.android.gms.ads.LoadAdError
import com.google.android.gms.ads.nativead.NativeAd
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.concurrent.atomic.AtomicBoolean

/**
 * ÎÑ§Ïù¥Ìã∞Î∏å Í¥ëÍ≥† Î°úÎçî Î∞è Ï†ïÏ±Ö Í¥ÄÎ¶¨ Ïã±Í∏ÄÌÜ§
 * - ÎîîÎ≤ÑÍ∑∏: Ï†ïÏ±Ö Ïö∞Ìöå, Ìï≠ÏÉÅ ÌóàÏö©
 * - Î¶¥Î¶¨Ï¶à: ÏùºÏùº Ï∫°(1-2Ìöå), Ïø®Îã§Ïö¥(2Î∂Ñ), UMP ÎèôÏùò Í≤åÏù¥ÌåÖ
 */
object NativeAdManager {
    private const val TAG = "NativeAdManager"

    // Google ÌÖåÏä§Ìä∏ ÎÑ§Ïù¥Ìã∞Î∏å Advanced Ïú†Îãõ ID
    private const val GOOGLE_TEST_NATIVE_ID = "ca-app-pub-3940256099942544/2247696110"

    private fun currentUnitId(): String {
        val id = BuildConfig.ADMOB_NATIVE_UNIT_ID
        return if (id.isBlank() || id.contains("REPLACE_WITH_REAL_NATIVE")) {
            GOOGLE_TEST_NATIVE_ID
        } else {
            id
        }
    }

    // Ï†ïÏ±Ö Í∏∞Î≥∏Í∞í
    private const val DEFAULT_DAILY_CAP = 2 // Îí§Î°úÍ∞ÄÍ∏∞ ÌåùÏóÖ: ÌïòÎ£® ÏµúÎåÄ 2Ìöå
    private const val DEFAULT_COOLDOWN_MS = 2 * 60 * 1000L // 2Î∂Ñ

    private const val PREFS = "ad_prefs"
    private const val KEY_NATIVE_LAST_SHOWN_MS = "native_last_shown_ms"
    private const val KEY_NATIVE_DAILY_COUNT = "native_daily_count"
    private const val KEY_NATIVE_DAILY_DAY = "native_daily_day"

    private var cachedNativeAd: NativeAd? = null
    private val isLoading = AtomicBoolean(false)

    private fun isPolicyBypassed(): Boolean = BuildConfig.DEBUG

    /**
     * ÎÑ§Ïù¥Ìã∞Î∏å Í¥ëÍ≥† ÎØ∏Î¶¨ Î°úÎìú
     */
    fun preload(context: Context) {
        if (isLoading.get()) {
            Log.d(TAG, "Already loading, skip")
            return
        }
        if (cachedNativeAd != null) {
            Log.d(TAG, "Ad already loaded, skip")
            return
        }

        // ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÉÅÌÉú Ï≤¥ÌÅ¨
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as? ConnectivityManager
        @Suppress("DEPRECATION")
        val networkInfo = connectivityManager?.activeNetworkInfo
        @Suppress("DEPRECATION")
        if (networkInfo == null || !networkInfo.isConnected) {
            Log.w(TAG, "‚ö†Ô∏è No network connection, skip ad loading")
            return
        }

        isLoading.set(true)
        val unitId = currentUnitId()
        Log.d(TAG, "üîÑ Loading native ad with unitId=$unitId (debug=${BuildConfig.DEBUG})")
        @Suppress("DEPRECATION")
        Log.d(TAG, "   Network: ${networkInfo.typeName}, Connected: ${networkInfo.isConnected}")

        val adLoader = AdLoader.Builder(context, unitId)
            .forNativeAd { nativeAd ->
                Log.d(TAG, "‚úÖ Native ad loaded successfully")
                cachedNativeAd = nativeAd
                isLoading.set(false)
            }
            .withAdListener(object : com.google.android.gms.ads.AdListener() {
                override fun onAdFailedToLoad(error: LoadAdError) {
                    Log.e(TAG, "‚ùå Native ad failed to load:")
                    Log.e(TAG, "   - Error code: ${error.code}")
                    Log.e(TAG, "   - Error domain: ${error.domain}")
                    Log.e(TAG, "   - Error message: ${error.message}")
                    Log.e(TAG, "   - Response info: ${error.responseInfo}")

                    // ÏóêÎü¨ ÏΩîÎìúÎ≥Ñ Ï≤òÎ¶¨
                    when (error.code) {
                        0 -> Log.e(TAG, "   ‚ö†Ô∏è ERROR_CODE_INTERNAL_ERROR - ÏùºÏãúÏ†Å Î¨∏Ï†ú, Ïû¨ÏãúÎèÑ Í∞ÄÎä•")
                        1 -> Log.e(TAG, "   ‚ö†Ô∏è ERROR_CODE_INVALID_REQUEST - Í¥ëÍ≥† ÏöîÏ≤≠ ÏÑ§Ï†ï ÌôïÏù∏ ÌïÑÏöî")
                        2 -> Log.e(TAG, "   ‚ö†Ô∏è ERROR_CODE_NETWORK_ERROR - ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ Î¨∏Ï†ú")
                        3 -> Log.e(TAG, "   ‚ÑπÔ∏è ERROR_CODE_NO_FILL - ÌòÑÏû¨ ÌëúÏãúÌï† Í¥ëÍ≥† ÏóÜÏùå (Ï†ïÏÉÅ)")
                    }

                    cachedNativeAd = null
                    isLoading.set(false)

                    // ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò Ïãú 30Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ
                    if (error.code == 2 || error.code == 0) {
                        Log.d(TAG, "   üîÑ Will retry in 30 seconds...")
                        android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                            preload(context.applicationContext)
                        }, 30000)
                    }
                }

                override fun onAdOpened() {
                    Log.d(TAG, "Native ad opened")
                }

                override fun onAdClosed() {
                    Log.d(TAG, "Native ad closed")
                }

                override fun onAdClicked() {
                    Log.d(TAG, "Native ad clicked")
                }
            })
            .build()

        adLoader.loadAd(AdRequest.Builder().build())
    }

    /**
     * Î°úÎìúÎêú ÎÑ§Ïù¥Ìã∞Î∏å Í¥ëÍ≥† ÌöçÎìù (ÏÜåÏú†Í∂å Ïù¥Ï†Ñ)
     * Ìò∏Ï∂úÏûêÎäî Î∞òÎìúÏãú ÏÇ¨Ïö© ÌõÑ destroy() Ìò∏Ï∂ú ÌïÑÏöî
     */
    fun acquire(context: Context): NativeAd? {
        val ad = cachedNativeAd
        cachedNativeAd = null
        if (ad != null) {
            Log.d(TAG, "‚úÖ Ad acquired, will reload in background")
            // Ï¶âÏãú Îã§Ïùå Í¥ëÍ≥† Î°úÎìú ÏãúÏûë
            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                preload(context.applicationContext)
            }, 1000)
        } else {
            Log.w(TAG, "‚ö†Ô∏è No ad available to acquire")
        }
        return ad
    }

    /**
     * Í¥ëÍ≥†Í∞Ä Î°úÎìúÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
     */
    fun isLoaded(): Boolean = cachedNativeAd != null

    /**
     * Ï†ïÏ±Ö Ï≤¥ÌÅ¨: Í¥ëÍ≥† ÌëúÏãúÍ∞Ä ÌóàÏö©ÎêòÎäîÏßÄ ÌôïÏù∏
     * @return true if allowed, false otherwise
     */
    fun canShowAd(context: Context): Boolean {
        if (isPolicyBypassed()) {
            Log.d(TAG, "Policy bypassed (DEBUG)")
            return true
        }

        val prefs = context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
        val now = System.currentTimeMillis()
        val todayKey = currentDayKey()

        // ÏùºÏùº Ïπ¥Ïö¥Ìä∏ Ï≤¥ÌÅ¨
        val storedDay = prefs.getString(KEY_NATIVE_DAILY_DAY, "")
        val dailyCount = if (storedDay == todayKey) {
            prefs.getInt(KEY_NATIVE_DAILY_COUNT, 0)
        } else {
            0 // ÎÇ†ÏßúÍ∞Ä Î∞îÎÄåÎ©¥ Ï¥àÍ∏∞Ìôî
        }

        if (dailyCount >= DEFAULT_DAILY_CAP) {
            Log.d(TAG, "Daily cap reached ($dailyCount/$DEFAULT_DAILY_CAP)")
            return false
        }

        // Ïø®Îã§Ïö¥ Ï≤¥ÌÅ¨
        val lastShown = prefs.getLong(KEY_NATIVE_LAST_SHOWN_MS, 0L)
        val elapsed = now - lastShown
        if (elapsed < DEFAULT_COOLDOWN_MS) {
            val remainSec = (DEFAULT_COOLDOWN_MS - elapsed) / 1000
            Log.d(TAG, "Cooldown active (remain ${remainSec}s)")
            return false
        }

        return true
    }

    /**
     * Í¥ëÍ≥† ÌëúÏãú ÌõÑ Ìò∏Ï∂ú (Ï†ïÏ±Ö Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏)
     */
    fun recordShown(context: Context) {
        if (isPolicyBypassed()) {
            Log.d(TAG, "Policy bypassed, skip recording")
            return
        }

        val prefs = context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
        val now = System.currentTimeMillis()
        val todayKey = currentDayKey()

        val storedDay = prefs.getString(KEY_NATIVE_DAILY_DAY, "")
        val dailyCount = if (storedDay == todayKey) {
            prefs.getInt(KEY_NATIVE_DAILY_COUNT, 0)
        } else {
            0
        }

        prefs.edit()
            .putLong(KEY_NATIVE_LAST_SHOWN_MS, now)
            .putInt(KEY_NATIVE_DAILY_COUNT, dailyCount + 1)
            .putString(KEY_NATIVE_DAILY_DAY, todayKey)
            .apply()

        Log.d(TAG, "Recorded show: count=${dailyCount + 1}/$DEFAULT_DAILY_CAP")

        // Î∞îÎ°ú Ïû¨Î°úÎìú ÏãúÏûë
        val appContext = context.applicationContext
        android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
            preload(appContext)
        }, 500)
    }

    private fun currentDayKey(): String {
        return SimpleDateFormat("yyyyMMdd", Locale.US).format(Date())
    }
}

